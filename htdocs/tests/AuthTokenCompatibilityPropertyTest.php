<?php
/**
 * Authentication Token Compatibility Property Test
 * 
 * **Property 4: Authentication Token Compatibility**
 * **Validates: Requirements 3.1**
 * 
 * For any valid JWT token generated by either system, both the Node and PHP 
 * backends should be able to validate and extract the same user information.
 * 
 * This test verifies that JWT tokens are compatible between Node.js and PHP
 * implementations by testing token format, signature validation, and payload
 * extraction consistency.
 */

require_once __DIR__ . '/../config/jwt.php';
require_once __DIR__ . '/../utils/Logger.php';

class AuthTokenCompatibilityPropertyTest extends PHPUnit\Framework\TestCase {
    private $jwtService;
    
    protected function setUp(): void {
        $this->jwtService = new JWTService();
    }
    
    /**
     * **Validates: Requirements 3.1**
     * Property: JWT Token Cross-Platform Compatibility
     * 
     * For any valid user payload, a JWT token generated by the PHP system
     * should be verifiable and should extract the same user information
     * consistently across different validation attempts.
     * 
     * @test
     */
    public function testJWTTokenCrossPlatformCompatibility() {
        for ($i = 0; $i < 100; $i++) {
            // Generate random but valid user payload
            $originalPayload = $this->generateValidUserPayload();
            
            // Generate token using PHP JWT service
            $token = $this->jwtService->generateAccessToken($originalPayload);
            
            // Verify token format is standard JWT (3 parts separated by dots)
            $this->assertTrue($this->jwtService->isValidTokenFormat($token));
            $parts = explode('.', $token);
            $this->assertCount(3, $parts, 'JWT token should have exactly 3 parts');
            
            // Verify each part is valid base64url encoding
            foreach ($parts as $part) {
                $this->assertMatchesRegularExpression('/^[A-Za-z0-9\-_]+$/', $part, 'JWT parts should be base64url encoded');
            }
            
            // Verify token can be decoded and validated multiple times consistently
            for ($j = 0; $j < 5; $j++) {
                $decodedPayload = $this->jwtService->verifyAccessToken($token);
                
                // Core user data should match exactly
                $this->assertEquals($originalPayload['user_id'], $decodedPayload['user_id']);
                $this->assertEquals($originalPayload['email'], $decodedPayload['email']);
                $this->assertEquals($originalPayload['role'], $decodedPayload['role']);
                
                // Standard JWT claims should be present
                $this->assertArrayHasKey('iat', $decodedPayload, 'Token should have issued at claim');
                $this->assertArrayHasKey('exp', $decodedPayload, 'Token should have expiration claim');
                $this->assertArrayHasKey('iss', $decodedPayload, 'Token should have issuer claim');
                $this->assertArrayHasKey('aud', $decodedPayload, 'Token should have audience claim');
                
                // Verify timestamp claims are reasonable
                $now = time();
                $this->assertLessThanOrEqual($now, $decodedPayload['iat'], 'Issued at should not be in future');
                $this->assertGreaterThan($now, $decodedPayload['exp'], 'Expiration should be in future');
                $this->assertGreaterThan($decodedPayload['iat'], $decodedPayload['exp'], 'Expiration should be after issued at');
            }
        }
    }
    
    /**
     * **Validates: Requirements 3.1**
     * Property: Token Signature Verification Consistency
     * 
     * For any JWT token, the signature verification should be deterministic
     * and consistent. Valid tokens should always verify, invalid tokens should always fail.
     * 
     * @test
     */
    public function testTokenSignatureVerificationConsistency() {
        for ($i = 0; $i < 100; $i++) {
            $userPayload = $this->generateValidUserPayload();
            $validToken = $this->jwtService->generateAccessToken($userPayload);
            
            // Valid token should always verify successfully
            for ($j = 0; $j < 5; $j++) {
                $payload = $this->jwtService->verifyAccessToken($validToken);
                $this->assertIsArray($payload, 'Valid token should always decode to array');
                $this->assertEquals($userPayload['user_id'], $payload['user_id']);
            }
            
            // Tampered tokens should always fail verification
            $tamperedTokens = $this->generateTamperedTokens($validToken);
            
            foreach ($tamperedTokens as $description => $tamperedToken) {
                $verificationFailed = false;
                
                try {
                    $this->jwtService->verifyAccessToken($tamperedToken);
                } catch (Exception $e) {
                    $verificationFailed = true;
                    $this->assertStringContainsString('Invalid', $e->getMessage(), 
                        "Error message should indicate invalid token for: $description");
                }
                
                $this->assertTrue($verificationFailed, 
                    "Tampered token should fail verification: $description");
            }
        }
    }
    
    /**
     * **Validates: Requirements 3.1**
     * Property: Token Payload Structure Consistency
     * 
     * For any user data, the generated JWT token should contain all required
     * fields in the expected format, compatible with Node.js JWT libraries.
     * 
     * @test
     */
    public function testTokenPayloadStructureConsistency() {
        for ($i = 0; $i < 100; $i++) {
            $userPayload = $this->generateValidUserPayload();
            $token = $this->jwtService->generateAccessToken($userPayload);
            $decodedPayload = $this->jwtService->verifyAccessToken($token);
            
            // Required user fields should be preserved
            $requiredUserFields = ['user_id', 'email', 'role'];
            foreach ($requiredUserFields as $field) {
                $this->assertArrayHasKey($field, $decodedPayload, "Token should contain $field");
                $this->assertEquals($userPayload[$field], $decodedPayload[$field], 
                    "Token $field should match original value");
            }
            
            // Standard JWT claims should be present and valid
            $requiredJwtClaims = ['iat', 'exp', 'iss', 'aud'];
            foreach ($requiredJwtClaims as $claim) {
                $this->assertArrayHasKey($claim, $decodedPayload, "Token should contain $claim claim");
            }
            
            // Verify claim types and values
            $this->assertIsInt($decodedPayload['iat'], 'iat should be integer timestamp');
            $this->assertIsInt($decodedPayload['exp'], 'exp should be integer timestamp');
            $this->assertIsString($decodedPayload['iss'], 'iss should be string');
            $this->assertIsString($decodedPayload['aud'], 'aud should be string');
            
            // Verify issuer and audience match configuration
            $config = JWTConfig::getConfig();
            $this->assertEquals($config['issuer'], $decodedPayload['iss'], 'Issuer should match config');
            $this->assertEquals($config['audience'], $decodedPayload['aud'], 'Audience should match config');
        }
    }
    
    /**
     * **Validates: Requirements 3.1**
     * Property: Token Expiration Handling Consistency
     * 
     * For any JWT token, expiration handling should be consistent and predictable.
     * Expired tokens should always fail validation.
     * 
     * @test
     */
    public function testTokenExpirationHandlingConsistency() {
        // Test with very short expiration for immediate expiry
        $originalConfig = JWTConfig::getConfig();
        
        // Create a service with short expiration for testing
        $shortExpiryService = new class extends JWTService {
            public function generateShortLivedToken($payload) {
                $now = time();
                $tokenPayload = array_merge($payload, [
                    'iat' => $now,
                    'exp' => $now - 1, // Already expired
                    'iss' => 'riya-collections',
                    'aud' => 'riya-collections-users'
                ]);
                
                $config = JWTConfig::getConfig();
                return JWT::encode($tokenPayload, $config['secret'], $config['algorithm']);
            }
        };
        
        for ($i = 0; $i < 50; $i++) {
            $userPayload = $this->generateValidUserPayload();
            
            // Generate expired token
            $expiredToken = $shortExpiryService->generateShortLivedToken($userPayload);
            
            // Expired token should always fail verification
            $verificationFailed = false;
            try {
                $this->jwtService->verifyAccessToken($expiredToken);
            } catch (Exception $e) {
                $verificationFailed = true;
                $this->assertStringContainsString('expired', strtolower($e->getMessage()), 
                    'Error message should indicate token expiration');
            }
            
            $this->assertTrue($verificationFailed, 'Expired token should always fail verification');
        }
    }
    
    /**
     * **Validates: Requirements 3.1**
     * Property: Refresh Token Compatibility
     * 
     * For any user payload, refresh tokens should be generated with proper
     * type markers and should be distinguishable from access tokens.
     * 
     * @test
     */
    public function testRefreshTokenCompatibility() {
        for ($i = 0; $i < 100; $i++) {
            $userPayload = $this->generateValidUserPayload();
            
            // Generate token pair
            $tokenPair = $this->jwtService->generateTokenPair($userPayload);
            
            // Verify token pair structure
            $this->assertArrayHasKey('access_token', $tokenPair);
            $this->assertArrayHasKey('refresh_token', $tokenPair);
            $this->assertArrayHasKey('token_type', $tokenPair);
            $this->assertArrayHasKey('expires_in', $tokenPair);
            
            // Verify token type
            $this->assertEquals('Bearer', $tokenPair['token_type']);
            $this->assertIsInt($tokenPair['expires_in']);
            $this->assertGreaterThan(0, $tokenPair['expires_in']);
            
            // Verify both tokens are valid JWT format
            $this->assertTrue($this->jwtService->isValidTokenFormat($tokenPair['access_token']));
            $this->assertTrue($this->jwtService->isValidTokenFormat($tokenPair['refresh_token']));
            
            // Verify access token payload
            $accessPayload = $this->jwtService->verifyAccessToken($tokenPair['access_token']);
            $this->assertEquals($userPayload['user_id'], $accessPayload['user_id']);
            $this->assertEquals($userPayload['email'], $accessPayload['email']);
            $this->assertEquals($userPayload['role'], $accessPayload['role']);
            
            // Verify refresh token payload and type marker
            $refreshPayload = $this->jwtService->verifyRefreshToken($tokenPair['refresh_token']);
            $this->assertEquals($userPayload['user_id'], $refreshPayload['user_id']);
            $this->assertEquals($userPayload['email'], $refreshPayload['email']);
            $this->assertEquals($userPayload['role'], $refreshPayload['role']);
            $this->assertEquals('refresh', $refreshPayload['type'], 'Refresh token should have type marker');
            
            // Verify tokens are different
            $this->assertNotEquals($tokenPair['access_token'], $tokenPair['refresh_token'], 
                'Access and refresh tokens should be different');
        }
    }
    
    /**
     * Generate valid user payload for testing
     */
    private function generateValidUserPayload() {
        $roles = ['customer', 'admin'];
        $domains = ['example.com', 'test.org', 'demo.net'];
        
        return [
            'user_id' => rand(1, 999999),
            'email' => 'user' . rand(1000, 9999) . '@' . $domains[array_rand($domains)],
            'role' => $roles[array_rand($roles)]
        ];
    }
    
    /**
     * Generate various tampered versions of a token for testing
     */
    private function generateTamperedTokens($validToken) {
        $parts = explode('.', $validToken);
        $tamperedTokens = [];
        
        // Tamper with header
        $tamperedHeader = $this->modifyBase64String($parts[0]);
        $tamperedTokens['modified_header'] = $tamperedHeader . '.' . $parts[1] . '.' . $parts[2];
        
        // Tamper with payload
        $tamperedPayload = $this->modifyBase64String($parts[1]);
        $tamperedTokens['modified_payload'] = $parts[0] . '.' . $tamperedPayload . '.' . $parts[2];
        
        // Tamper with signature
        $tamperedSignature = $this->modifyBase64String($parts[2]);
        $tamperedTokens['modified_signature'] = $parts[0] . '.' . $parts[1] . '.' . $tamperedSignature;
        
        // Completely invalid token
        $tamperedTokens['invalid_format'] = 'invalid.token';
        
        // Empty token
        $tamperedTokens['empty_token'] = '';
        
        // Token with wrong number of parts
        $tamperedTokens['wrong_parts'] = $parts[0] . '.' . $parts[1];
        
        return $tamperedTokens;
    }
    
    /**
     * Modify a base64url string slightly
     */
    private function modifyBase64String($base64String) {
        if (empty($base64String)) {
            return 'modified';
        }
        
        // Change one character
        $pos = rand(0, strlen($base64String) - 1);
        $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
        $currentChar = $base64String[$pos];
        
        // Find a different character
        do {
            $newChar = $chars[rand(0, strlen($chars) - 1)];
        } while ($newChar === $currentChar);
        
        return substr_replace($base64String, $newChar, $pos, 1);
    }
}